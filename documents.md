RDBの基礎設計

# 今日やる事

DBの設計についての話
- 論理設計
- 物理設計

メインは論理設計<br>
プラス小話

# 今日話さないこと

SQLについて


# 初めにDBとは

「用途に応じて加工や再利用がしやすいよう、一定の形式で作成、管理されたデータの集合のこと」<br>
出典 e-words データベース

## DBにはいくつかのモデルが存在する
- リレーショナルデータベース(RDB)<br>
  データを「二次元の表形式」で表現
- キーバリュー型ストア(KVS)<br>
  データをキー(識別キー)とバリュー(値)を組み合わせただけの単純なデータ型で表現<br>
  単純なデータ問い合わせを高速化することを目的としている
- XMLデータベース(XMLDB)
  XML形式のデータを扱うことが出来る<br>
  階層構造を扱うのが得意
- オブジェクトデータベース(OODB)
  オブジェクト指向で言うオブジェクトをデータベースに保存する

今回扱うのは初めのRDBについて

## RDBMSって

RDBについて非常によくある間違いは、DBを単なるデータの入れ物だと考えること<br>
->インデックスさえちゃんと効いていれば高速にアクセスできるため、DB設計、つまり個々のテーブル設計やDB全体の統合性はどうでもよいという考え<br>

これは間違い

じゃあDBはどうあるべき？<br>
->データを整合的に保持して簡単に利用出来る状態にしておく


### 代表的なRDBMS
- Oracle Database
  RDBMSの中で最大のシェアを持つ
- SQL Server
  Windowsプラットフォームに特化したDBMS
- DB2
  IBM製のUNIX,Windows,メインフレームOSといったマルチプラットフォーム対応のDBMS

ここまでが有料のDBMS

- PostgreSQL
  米バークレイ大学で開発されたオープンソースのDBMS
- MySQL
  サン・マイクロシステムズが所有していたが、現在はOracleが所有するオープンソースのDBMS

RDBMSの違いでRDBの設計技法に違いも出るのか？<br>
->答えは「No」 <br>
  ※各DBMSの実装によって機能が異なることはある


# ここから設計の話


## まずは3層スキーマについて

スキーマ: 「枠組みや構図という意味だが、データベース設計においてはデータ構造やフォーマットという意味」

スキーマは3つのレベルに分けられる
- 外部スキーマ(外部モデル) = ビューの世界
- 概念スキーマ(論理モデル) = テーブルの世界
- 内部スキーマ(物理データモデル) = ファイルの世界

外部スキーマや内部スキーマに概念スキーマを吸収させた2層スキーマも存在するが、3層に比べると変更に対する柔軟性が低い


DB設計の大半は論理設計と物理設計<br>
流れとしては<br>
論理設計(概念スキーマ) -> 物理設計(内部スキーマ)<br>
の順番で行う


# 論理設計の話

システムの世界では「論理」という言葉がよく登場するが、通常の日本語の意味である「整合的で意味が通っている」という意味ではなく「物理層の制約にとらわれない」という意味

※物理層の制約: DBサーバーのCPUやストレージ、DBMSのデータ型やSQLの構文などのより具体的で実装レベルでの条件のこと

論理設計では何をするのか<br>
現実世界に存在する数多くのデータから、RDBにおいて何をどのようなフォーマットで保存するかを決める

## 論理設計のステップ

1. エンティティの抽出
2. エンティティの定義
3. 正規化
4. ER図の作成

### 各ステップのポイント

#### エンティティの抽出
エンティティ: <br>
「実体」<br>
世界に存在するデータの集合体を指す言葉で具体的には「顧客」や「店舗」のように物理的実態を伴ったものもあれば<br>
「メッセージ」や「注文履歴」のように単なる概念としてしか存在しないものも含まれる

RDBでは最終的にこうした現実世界のエンティティをテーブルという物理的単位で格納していくことになる<br>
そのためまずは、システムのためにどのようなエンティティ(=データ)が必要になってくるかを抽出することが論理設計の第一ステップ

#### エンティティの定義
各エンティティがどのようなデータを保持するかを決める<br>
エンティティはデータを「属性」という形で保存する<br>
これは二次元表における「列」と同義と考えてよい<br>


#### 正規化

何をするのか<br>
データの更新が整合的に行えるようにエンティティを分割する<br>
単にエンティティを抽出し属性を定義しただけの状態では、まだそのエンティティはシステムでの利用に耐えうる状態になっていない

正規化をすると<br>
データの整合性を保持できる、データの矛盾を防ぐことが出来る

テーブル分割するので更新系の処理が軽くなる

RBDの論理設計ではこの正規化が最も重要

#### ER図の作成
正規化を行うとエンティティの数が増える<br>
そうするとエンティティ同士の関係が把握しにくくなるという問題が起こる<br>

その問題を解決するために考案されたのがエンティティ同士の関係を表現する図を作成する

無くても論理設計は可能だがあると開発の時に助かる


## 正規化と正規形

### 正規系とは(なぜ正規化するのか)

正規形: 「データベースで保持するデータの冗長性を排除し、一貫性と効率性を保持するためのデータベース形式」

冗長性: 「1つの情報が複数のテーブルに存在して無駄なデータ領域と面倒な更新処理を発生させてしまう」

こうした冗長なデータ保持をしていると更新処理によってデータ不整合が発生したり、データを登録できないようなテーブルを作ってしまうことがある<br>
こうした問題を解決するために考案された方法が正規化

### 正規化のレベル

正規化には段階がある

- 第1正規形
- 第2正規形
- 第3正規形
- ボイスーコッド正規形
- 第4正規形
- 第5正規形

実務で利用する分には第三正規形までしておけばOK

### 第1正規形 - スカラ値の原則

テーブルの行と列が交差する特定の1マスのことをスプレッドシート用語に習って「セル」と呼ぶことにする

第1正規形の定義

> 1つのセルの中には1つの値しか含まない

自分の好きなプログラミング言語を管理するテーブルで考えてみる

users

| id          | name           | language     |
|:-----------:|:--------------:|:------------:|
| A0001       | kai            |     Ruby     |
| A0002       | kohama         |     Java     |
| A0003       | oshikawa       |     Scala    |
| A0004       | udonishi       |     C++      |

このように1つのセルに1つだけの値が含まれている時、この値のことをスカラ値と呼ぶ<br>
※　scalar: 「単体」


ここから第1正規形を作っていく

定義の再確認「1つのセルに1つの値」// 当たり前じゃないか

こういう場合はどうか

| id          | name           | language     |
|:-----------:|:--------------:|:------------:|
| A0001       | kai            | Python, Ruby |
| A0002       | kohama         | Java, JS     |
| A0003       | oshikawa       | Scala        |
| A0004       | udonishi       | C++, Java    |

1つのセルにカンマ区切りで1つ以上の値が入ってしまっている<br>
-> 非正規系


定義通りにテーブルを変更してみる


##### 第1正規形 その1

| id          | name           | language1  |language2  |
|:-----------:|:--------------:|:----------:|:---------:|
| A0001       | kai            | Python     | Ruby      |
| A0002       | kohama         | Java       | JS        |
| A0003       | oshikawa       | Scala      |           |
| A0004       | udonishi       | C++        | Java      |

1つのセルに1つの値

##### 第1正規形 その2

| id          | name           | language     |
|:-----------:|:--------------:|:------------:|
| A0001       | kai            | Python       |
| A0001       | kai            | Ruby         |
| A0002       | kohama         | Java         |
| A0002       | kohama         | JS           |
| A0003       | oshikawa       | Scala        |
| A0004       | udonishi       | C++          |
| A0004       | udonishi       | Java         |

1つのセルに1つの値


第1正規形 簡単やないか！！

違う

これらには問題がある

まずその1

同じデータを持つはずのカラムが2つ存在している(language1, language2)<br>

これはSQLアンチパターンである「マルチカラムアトリビュート（複数列属性）」<br>
システムの仕様でこれらの値が'絶対'2つ以上にならない場合などは適用してもよいらしいが大抵の場合、こういう設計は問題になる<br>
※検索時のインデックス、値の重複をプログラム側で実装しなければならない、仕様変更で2つ以上の値を追加したい時等

その2

このテーブル設計には


### 第二正規形~部分関数従属

2016/07/14

### 第三正規形~推移的関数従属
### ボイスーコッド正規形

2016/07/16

## 論理設計とパフォーマンスの話
## 設計のアンチパターン

・正規化を進めていくほどデータの整合性は高まるが検索性能が劣化する(但し、まずはパフォーマンスを考えずに正規化は行うようにする)

# 物理設計の話
## 物理設計のステップ


1. テーブル定義
2. インデックス定義
3. ハードウェアのサイジング
4. ストレージの冗長構成決定
5. ファイルの物理配置決定

2016/07/18

## テーブル定義

2016/07/19

## index設計(インデックスによって受ける恩恵)

2016/07/20

### indexするべきテーブル、しないテーブル


### 予定ページ数
40くらい?

初めにDBとは 10p

論理設計の話 20p

物理設計の話 10p

### 時間余ったら
Qiitaスライドの紹介

DB/SQL界隈の話(RDB vs NoSQL, NULL賛否, SQLは人間が書くものではない)

テーブルのバージョン管理

RDBの得意不得意

### 使うスライド
Qiita slide mode

### リンク/参考
[達人に学ぶDB設計 徹底指南書]("https://www.amazon.co.jp/%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6DB%E8%A8%AD%E8%A8%88-%E5%BE%B9%E5%BA%95%E6%8C%87%E5%8D%97%E6%9B%B8-%E5%88%9D%E7%B4%9A%E8%80%85%E3%81%A7%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%9F%E3%81%8F%E3%81%AA%E3%81%84%E3%81%82%E3%81%AA%E3%81%9F%E3%81%B8-%E3%83%9F%E3%83%83%E3%82%AF/dp/4798124702" 達人に学ぶDB設計 徹底指南書)

[理論から学ぶデータベース実践入門]("https://www.amazon.co.jp/%E7%90%86%E8%AB%96%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B6%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E5%AE%9F%E8%B7%B5%E5%85%A5%E9%96%80-~%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AB%E3%82%88%E3%82%8B%E5%8A%B9%E7%8E%87%E7%9A%84%E3%81%AASQL-WEB-PRESS-plus/dp/4774171972/ref=sr_1_1?s=books&ie=UTF8&qid=1468226728&sr=1-1&keywords=%E7%90%86%E8%AB%96%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B6%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E5%AE%9F%E8%B7%B5%E5%85%A5%E9%96%80" 理論から学ぶデータベース実践入門)
